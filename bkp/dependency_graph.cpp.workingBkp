/**
 * dependency_graph.cpp
 *
 *  Created on: Mar 1, 2012
 *      Author: rbianchi@cern.ch  (Riccardo-Maria BIANCHI)
 */

// to print ROOT libs and paths: root-config --cflags --glibs


// include c++
# include <iostream>
# include <cstdio>
// include tbb
# include "tbb/task_scheduler_init.h"
#include "tbb/flow_graph.h"

using namespace std;
using namespace tbb::flow;


tbb::spin_mutex my_mutex;

const int setup_time = 1;

const char *algos[] = { "Chain1", "Chain2", "Chain3", "Chain4", "Chain5",
"Chain6", "Chain7", "Chain8", "Chain9", "Chain10" };




//===========================
//		timing tools
//===========================
typedef unsigned long long timestamp_t;
static timestamp_t get_timestamp () {
  struct timeval now;
  gettimeofday (&now, NULL);
  return  now.tv_usec + (timestamp_t)now.tv_sec * 1000000;
}




//===========================
//		AlgoChain class
//===========================

class AlgoChain {
public:
	AlgoChain(const char *name, tbb::flow::graph &the_graph, broadcast_node< continue_msg > &start) :
		m_name(name), m_graph(&the_graph), m_start(&start) {};
	virtual ~AlgoChain() {};
	void operator()();


private:
	struct body;
	const char* m_name;

	// pointers to main graph elements
	tbb::flow::graph* m_graph;
	broadcast_node< continue_msg >* m_start;

	// subgraph nodes
	continue_node<continue_msg>* m_algA;
	continue_node<continue_msg>* m_algB;
	continue_node<continue_msg>* m_algC;
	continue_node<continue_msg>* m_algD;
	continue_node<continue_msg>* m_algE;
	broadcast_node< continue_msg >* m_startNode;
	//tbb::flow::function_node< join_type::flow::output_type, tbb::flow::continue_msg > *my_function_node;

	//friend class node_body;

	void setup();
	void make_my_node();
};

void AlgoChain::operator()() {
  setup();
  make_my_node();
  m_startNode->try_put( continue_msg() );
}

void AlgoChain::setup() {
	printf("\t%s setting up\n", m_name );
	sleep(setup_time);
	printf("\t%s done setup\n", m_name );
}


struct AlgoChain::body {
    std::string my_name;
    std::string my_parentName;
    body( const char *name, const char* parentName ) : my_name(name), my_parentName(parentName) {}
    void operator()( continue_msg ) const {
    	tbb::spin_mutex::scoped_lock lock(my_mutex);
        printf("\t\t%s: algo %s\n", my_parentName.c_str(), my_name.c_str());
    }
};


void AlgoChain::make_my_node() {
	// TODO Auto-generated constructor stub

	m_startNode = new broadcast_node< continue_msg >(*m_graph);
	m_start->register_successor( *m_startNode );
	m_algA = new continue_node<continue_msg>( *m_graph, body( "A", m_name ));
	m_algB = new continue_node<continue_msg>( *m_graph, body( "B", m_name ));
	m_algC = new continue_node<continue_msg>( *m_graph, body( "C", m_name ));
	m_algD = new continue_node<continue_msg>( *m_graph, body( "D", m_name ));
	m_algE = new continue_node<continue_msg>( *m_graph, body( "E", m_name ));
	make_edge( *m_start, *m_startNode);
	make_edge( *m_startNode, *m_algA );
	make_edge( *m_startNode, *m_algB );
	make_edge( *m_algA, *m_algC );
	make_edge( *m_algB, *m_algC );
	make_edge( *m_algC, *m_algD );
	make_edge( *m_algA, *m_algE );

	tbb::spin_mutex::scoped_lock lock(my_mutex);
	printf("\t%s subgraph created\n", m_name);
}




int schedule(int num_algos) {


	// time it
	timestamp_t tstart = get_timestamp();

	// main graph
	printf("creating the main graph\n");
	graph g;
	broadcast_node< continue_msg > first_node(g);//maybe useless...

	// sub-graphs
	printf("creating the AlgoChains graphs\n");
	std::vector< AlgoChain > chains;
	for ( int i = 0; i < num_algos; ++i ) {
		chains.push_back( AlgoChain( algos[i], g, first_node ) );
		g.run( chains[i] );
	}

	tbb::spin_mutex::scoped_lock lock;

	// wait for all completing
	lock.acquire(my_mutex);
	printf("waiting for all completing\n");
	lock.release();
	g.wait_for_all();

	// time it
	timestamp_t tstop = get_timestamp();
	timestamp_t totTime = tstop-tstart;
	printf("elapsed time: %llu \n", totTime);

	return totTime;
}



//===========================
//		MAIN
//===========================

int main(int argc, char *argv[]) {

	// default threads and algos
	int num_threads = 1;
	int num_algos = 10;

	// command-line parser
	if ( argc > 1 ) num_threads = atoi(argv[1]);
	if ( argc > 2 ) num_algos = atoi(argv[2]);

	if ( num_threads < 1 || num_algos < 1 || num_algos > 10 ) exit(1);

	// enabling a certain number of working threads
	printf("Init %i working threads\n", num_threads);
	tbb::task_scheduler_init init(num_threads); //apparently this value can be changed only once per application run


	bool test = false;
	if ( argc > 3 && atoi(argv[3]) == 1 ) test = true;

	if(test) {
			timestamp_t time = 0;
			int times = 0;
			for (int nn=0; nn<5; ++nn) {
				time += schedule(num_algos);
				++times;
			}
			printf("%i threads - %i algos - Time: %f\n\n\n", num_threads, num_algos, time/(double)times );
	}
	else {
		schedule(num_algos);
	}

    return 0;
}

